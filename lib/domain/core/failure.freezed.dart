// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ClientFailureTearOff {
  const _$ClientFailureTearOff();

  _GettingWithNullValue<T> gettingClientWithNullValue<T>() {
    return _GettingWithNullValue<T>();
  }

  _ClientNotFound<T> clientNotFound<T>() {
    return _ClientNotFound<T>();
  }

  _ServerError<T> serverError<T>() {
    return _ServerError<T>();
  }

  _PermissionDenied<T> permissionDenied<T>() {
    return _PermissionDenied<T>();
  }

  _UnknownError<T> unknownError<T>({T? object}) {
    return _UnknownError<T>(
      object: object,
    );
  }
}

/// @nodoc
const $ClientFailure = _$ClientFailureTearOff();

/// @nodoc
mixin _$ClientFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClientFailureCopyWith<T, $Res> {
  factory $ClientFailureCopyWith(
          ClientFailure<T> value, $Res Function(ClientFailure<T>) then) =
      _$ClientFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ClientFailureCopyWithImpl<T, $Res>
    implements $ClientFailureCopyWith<T, $Res> {
  _$ClientFailureCopyWithImpl(this._value, this._then);

  final ClientFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ClientFailure<T>) _then;
}

/// @nodoc
abstract class _$GettingWithNullValueCopyWith<T, $Res> {
  factory _$GettingWithNullValueCopyWith(_GettingWithNullValue<T> value,
          $Res Function(_GettingWithNullValue<T>) then) =
      __$GettingWithNullValueCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$GettingWithNullValueCopyWithImpl<T, $Res>
    extends _$ClientFailureCopyWithImpl<T, $Res>
    implements _$GettingWithNullValueCopyWith<T, $Res> {
  __$GettingWithNullValueCopyWithImpl(_GettingWithNullValue<T> _value,
      $Res Function(_GettingWithNullValue<T>) _then)
      : super(_value, (v) => _then(v as _GettingWithNullValue<T>));

  @override
  _GettingWithNullValue<T> get _value =>
      super._value as _GettingWithNullValue<T>;
}

/// @nodoc

class _$_GettingWithNullValue<T>
    with DiagnosticableTreeMixin
    implements _GettingWithNullValue<T> {
  const _$_GettingWithNullValue();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientFailure<$T>.gettingClientWithNullValue()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'ClientFailure<$T>.gettingClientWithNullValue'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _GettingWithNullValue<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) {
    return gettingClientWithNullValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) {
    return gettingClientWithNullValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) {
    if (gettingClientWithNullValue != null) {
      return gettingClientWithNullValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) {
    return gettingClientWithNullValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) {
    return gettingClientWithNullValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) {
    if (gettingClientWithNullValue != null) {
      return gettingClientWithNullValue(this);
    }
    return orElse();
  }
}

abstract class _GettingWithNullValue<T> implements ClientFailure<T> {
  const factory _GettingWithNullValue() = _$_GettingWithNullValue<T>;
}

/// @nodoc
abstract class _$ClientNotFoundCopyWith<T, $Res> {
  factory _$ClientNotFoundCopyWith(
          _ClientNotFound<T> value, $Res Function(_ClientNotFound<T>) then) =
      __$ClientNotFoundCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$ClientNotFoundCopyWithImpl<T, $Res>
    extends _$ClientFailureCopyWithImpl<T, $Res>
    implements _$ClientNotFoundCopyWith<T, $Res> {
  __$ClientNotFoundCopyWithImpl(
      _ClientNotFound<T> _value, $Res Function(_ClientNotFound<T>) _then)
      : super(_value, (v) => _then(v as _ClientNotFound<T>));

  @override
  _ClientNotFound<T> get _value => super._value as _ClientNotFound<T>;
}

/// @nodoc

class _$_ClientNotFound<T>
    with DiagnosticableTreeMixin
    implements _ClientNotFound<T> {
  const _$_ClientNotFound();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientFailure<$T>.clientNotFound()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClientFailure<$T>.clientNotFound'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ClientNotFound<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) {
    return clientNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) {
    return clientNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) {
    if (clientNotFound != null) {
      return clientNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) {
    return clientNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) {
    return clientNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) {
    if (clientNotFound != null) {
      return clientNotFound(this);
    }
    return orElse();
  }
}

abstract class _ClientNotFound<T> implements ClientFailure<T> {
  const factory _ClientNotFound() = _$_ClientNotFound<T>;
}

/// @nodoc
abstract class _$ServerErrorCopyWith<T, $Res> {
  factory _$ServerErrorCopyWith(
          _ServerError<T> value, $Res Function(_ServerError<T>) then) =
      __$ServerErrorCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$ServerErrorCopyWithImpl<T, $Res>
    extends _$ClientFailureCopyWithImpl<T, $Res>
    implements _$ServerErrorCopyWith<T, $Res> {
  __$ServerErrorCopyWithImpl(
      _ServerError<T> _value, $Res Function(_ServerError<T>) _then)
      : super(_value, (v) => _then(v as _ServerError<T>));

  @override
  _ServerError<T> get _value => super._value as _ServerError<T>;
}

/// @nodoc

class _$_ServerError<T>
    with DiagnosticableTreeMixin
    implements _ServerError<T> {
  const _$_ServerError();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientFailure<$T>.serverError()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClientFailure<$T>.serverError'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ServerError<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _ServerError<T> implements ClientFailure<T> {
  const factory _ServerError() = _$_ServerError<T>;
}

/// @nodoc
abstract class _$PermissionDeniedCopyWith<T, $Res> {
  factory _$PermissionDeniedCopyWith(_PermissionDenied<T> value,
          $Res Function(_PermissionDenied<T>) then) =
      __$PermissionDeniedCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$PermissionDeniedCopyWithImpl<T, $Res>
    extends _$ClientFailureCopyWithImpl<T, $Res>
    implements _$PermissionDeniedCopyWith<T, $Res> {
  __$PermissionDeniedCopyWithImpl(
      _PermissionDenied<T> _value, $Res Function(_PermissionDenied<T>) _then)
      : super(_value, (v) => _then(v as _PermissionDenied<T>));

  @override
  _PermissionDenied<T> get _value => super._value as _PermissionDenied<T>;
}

/// @nodoc

class _$_PermissionDenied<T>
    with DiagnosticableTreeMixin
    implements _PermissionDenied<T> {
  const _$_PermissionDenied();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientFailure<$T>.permissionDenied()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClientFailure<$T>.permissionDenied'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PermissionDenied<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) {
    return permissionDenied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) {
    return permissionDenied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) {
    return permissionDenied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) {
    return permissionDenied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied(this);
    }
    return orElse();
  }
}

abstract class _PermissionDenied<T> implements ClientFailure<T> {
  const factory _PermissionDenied() = _$_PermissionDenied<T>;
}

/// @nodoc
abstract class _$UnknownErrorCopyWith<T, $Res> {
  factory _$UnknownErrorCopyWith(
          _UnknownError<T> value, $Res Function(_UnknownError<T>) then) =
      __$UnknownErrorCopyWithImpl<T, $Res>;
  $Res call({T? object});
}

/// @nodoc
class __$UnknownErrorCopyWithImpl<T, $Res>
    extends _$ClientFailureCopyWithImpl<T, $Res>
    implements _$UnknownErrorCopyWith<T, $Res> {
  __$UnknownErrorCopyWithImpl(
      _UnknownError<T> _value, $Res Function(_UnknownError<T>) _then)
      : super(_value, (v) => _then(v as _UnknownError<T>));

  @override
  _UnknownError<T> get _value => super._value as _UnknownError<T>;

  @override
  $Res call({
    Object? object = freezed,
  }) {
    return _then(_UnknownError<T>(
      object: object == freezed
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$_UnknownError<T>
    with DiagnosticableTreeMixin
    implements _UnknownError<T> {
  const _$_UnknownError({this.object});

  @override
  final T? object;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ClientFailure<$T>.unknownError(object: $object)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ClientFailure<$T>.unknownError'))
      ..add(DiagnosticsProperty('object', object));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UnknownError<T> &&
            const DeepCollectionEquality().equals(other.object, object));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(object));

  @JsonKey(ignore: true)
  @override
  _$UnknownErrorCopyWith<T, _UnknownError<T>> get copyWith =>
      __$UnknownErrorCopyWithImpl<T, _UnknownError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() gettingClientWithNullValue,
    required TResult Function() clientNotFound,
    required TResult Function() serverError,
    required TResult Function() permissionDenied,
    required TResult Function(T? object) unknownError,
  }) {
    return unknownError(object);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
  }) {
    return unknownError?.call(object);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? gettingClientWithNullValue,
    TResult Function()? clientNotFound,
    TResult Function()? serverError,
    TResult Function()? permissionDenied,
    TResult Function(T? object)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(object);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GettingWithNullValue<T> value)
        gettingClientWithNullValue,
    required TResult Function(_ClientNotFound<T> value) clientNotFound,
    required TResult Function(_ServerError<T> value) serverError,
    required TResult Function(_PermissionDenied<T> value) permissionDenied,
    required TResult Function(_UnknownError<T> value) unknownError,
  }) {
    return unknownError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
  }) {
    return unknownError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GettingWithNullValue<T> value)?
        gettingClientWithNullValue,
    TResult Function(_ClientNotFound<T> value)? clientNotFound,
    TResult Function(_ServerError<T> value)? serverError,
    TResult Function(_PermissionDenied<T> value)? permissionDenied,
    TResult Function(_UnknownError<T> value)? unknownError,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(this);
    }
    return orElse();
  }
}

abstract class _UnknownError<T> implements ClientFailure<T> {
  const factory _UnknownError({T? object}) = _$_UnknownError<T>;

  T? get object;
  @JsonKey(ignore: true)
  _$UnknownErrorCopyWith<T, _UnknownError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
